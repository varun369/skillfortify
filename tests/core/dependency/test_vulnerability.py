"""Tests for transitive vulnerability propagation through the ADG.

Validates that known-vulnerable (skill, version) pairs are correctly propagated
to all transitively-dependent nodes via reverse BFS on the dependency graph.
This is analogous to ``npm audit``'s transitive vulnerability analysis.
"""

from __future__ import annotations

from skillfortify.core.dependency import (
    AgentDependencyGraph,
    SkillConflict,
    SkillDependency,
    SkillNode,
    VersionConstraint,
)


# ===========================================================================
# Helpers
# ===========================================================================


def _make_node(
    name: str,
    version: str,
    deps: list[tuple[str, str]] | None = None,
    conflicts: list[tuple[str, str]] | None = None,
    capabilities: set[str] | None = None,
) -> SkillNode:
    """Convenience factory for SkillNode instances."""
    return SkillNode(
        name=name,
        version=version,
        dependencies=[
            SkillDependency(skill_name=d[0], constraint=VersionConstraint(d[1]))
            for d in (deps or [])
        ],
        conflicts=[
            SkillConflict(skill_name=c[0], constraint=VersionConstraint(c[1]))
            for c in (conflicts or [])
        ],
        capabilities=capabilities or set(),
    )


def _build_simple_chain() -> AgentDependencyGraph:
    """Build A@1.0.0 -> B@1.0.0 -> C@1.0.0 (linear dependency chain)."""
    g = AgentDependencyGraph()
    g.add_skill(_make_node("A", "1.0.0", deps=[("B", ">=1.0.0")]))
    g.add_skill(_make_node("B", "1.0.0", deps=[("C", ">=1.0.0")]))
    g.add_skill(_make_node("C", "1.0.0"))
    return g


def _build_diamond() -> AgentDependencyGraph:
    """Build a diamond dependency: A -> B, A -> C, B -> D, C -> D."""
    g = AgentDependencyGraph()
    g.add_skill(_make_node("A", "1.0.0", deps=[("B", ">=1.0.0"), ("C", ">=1.0.0")]))
    g.add_skill(_make_node("B", "1.0.0", deps=[("D", ">=1.0.0")]))
    g.add_skill(_make_node("C", "1.0.0", deps=[("D", ">=1.0.0")]))
    g.add_skill(_make_node("D", "1.0.0"))
    return g


# ===========================================================================
# Vulnerability Propagation
# ===========================================================================


class TestVulnerabilityPropagation:
    """Tests for transitive vulnerability propagation through the ADG."""

    def test_direct_dependency_propagation(self) -> None:
        """A depends on B. If B is vulnerable, A is affected."""
        g = _build_simple_chain()  # A -> B -> C
        affected = g.propagate_vulnerabilities({("B", "1.0.0")})
        assert ("A", "1.0.0") in affected
        assert ("B", "1.0.0") in affected[("A", "1.0.0")]

    def test_transitive_propagation(self) -> None:
        """A -> B -> C. If C is vulnerable, both A and B are affected."""
        g = _build_simple_chain()
        affected = g.propagate_vulnerabilities({("C", "1.0.0")})
        assert ("B", "1.0.0") in affected
        assert ("A", "1.0.0") in affected

    def test_diamond_propagation(self) -> None:
        """In diamond A -> B,C -> D, if D is vulnerable, A, B, C are all affected."""
        g = _build_diamond()
        affected = g.propagate_vulnerabilities({("D", "1.0.0")})
        assert ("B", "1.0.0") in affected
        assert ("C", "1.0.0") in affected
        assert ("A", "1.0.0") in affected

    def test_no_vulnerability_no_propagation(self) -> None:
        """Empty vulnerability set means no affected nodes."""
        g = _build_simple_chain()
        affected = g.propagate_vulnerabilities(set())
        assert affected == {}

    def test_leaf_vulnerability_no_reverse_path(self) -> None:
        """If A is vulnerable but nobody depends on A, no other node is affected."""
        g = _build_simple_chain()  # A -> B -> C
        affected = g.propagate_vulnerabilities({("A", "1.0.0")})
        # Nobody depends on A, so nobody else is affected
        assert len(affected) == 0
